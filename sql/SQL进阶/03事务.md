# 事务

------

在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分

这种把多条语句作为一个整体进行操作的功能，被称为数据库*事务*

**关于事务的定义有几点需要解释下：**

- 1.数据库事务可以包含一个或多个数据库操作,但这些操作构成一个逻辑上的整体。
- 2.构成逻辑整体的这些数据库操作,要么全部执行成功,要么全部不执行。
- 3.构成事务的所有操作,要么全都对数据库产生影响,要么全都不产生影响,即不管事务是否执行成功,数据库总能保持一致性状态。
- 4.以上即使在数据库出现故障以及并发事务存在的情况下依然成立。



数据库事务具有ACID这4个特性：

- A： Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；
- C： Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；
- I： Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；
- D： Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。

数据库系统是通过**并发控制技术**和**日志恢复技术**来避免这种情况发生的

![image-20210203193718996](C:\Users\Hexinan_cp\AppData\Roaming\Typora\typora-user-images\image-20210203193718996.png)

## 并发异常与并发控制技术

### 1.1脏写

脏写是指事务回滚了其他事务对数据项的已提交修改,比如下面这种情况 

```sql
事务1								事务2
read(A)=10					 
								 read(A)=10				
								 write(A)=30
								 commit
write(A)=20
rollback(A=10)
```

在事务1对数据A的回滚,导致事务2对A的已提交修改也被回滚了。

### 1.2丢失更新

```sql
事务1								事务2
								 read(A)=10
read(A)=10					 
								 A:=A+10				
								 commit
A:=A-10
commit(A=0)
```

事务1和事务2读取A的值都为10,事务2先将A加上10并提交修改,之后事务2将A减少10并提交修改,A的值最后为,导致事务2对A的修改好像丢失了一样

###  1.3脏读

脏读是指一个事务读取了另一个事务未提交的数据

```
事务1								事务2
read(A)=10
A:=A*2
write(A)=20
								 read(A)=20				
rollback(A=10)
```

在事务1对A的处理过程中,事务2读取了A的值,但之后事务1回滚,导致事务2读取的A是未提交的脏数据。

### 1.4不可重复读

不可重复读是指一个事务对同一数据的读取结果前后不一致。脏读和不可重复读的区别在于:前者读取的是事务未提交的脏数据,后者读取的是事务已经提交的数据,只不过因为数据被其他事务修改过导致前后两次读取的结果不一样,比如下面这种情况

```sql
事务1								事务2
read(A)=10
								 read(A)=10
								 A:=A*2
								 write(A)=20
								 read(A)=20				
read(A)=20
```

由于事务2对A的已提交修改,事务1前后两次读取的结果不一致

### 1.5幻读

幻读是指事务读取某个范围的数据时，因为其他事务的操作导致前后两次读取的结果不一致。幻读和不可重复读的区别在于,不可重复读是针对确定的某一行数据而言,而幻读是针对不确定的多行数据。因而幻读通常出现在带有查询条件的范围查询中





```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

`COMMIT`是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果`COMMIT`语句执行失败了，整个事务也会失败。

有些时候，我们希望主动让事务失败，这时，可以用`ROLLBACK`回滚事务，整个事务会失败：

## 隔离级别

1. 事务具有隔离性,理论上来说事务之间的执行不应该相互产生影响,其对数据库的影响应该和它们串行执行时一样。
2. 然而完全的隔离性会导致系统并发性能很低,降低对资源的利用率,因而实际上对隔离性的要求会有所放宽,这也会一定程度造成对数据库一致性要求降低

3. SQL标准为事务定义了不同的隔离级别,从低到高依次是

- 读未提交(READ UNCOMMITTED)
- 读已提交(READ COMMITTED)
- 可重复读(REPEATABLE READ)
- 串行化(SERIALIZABLE)

```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

​       事务的隔离级别越低,可能出现的并发异常越多,但是通常而言系统能提供的并发能力越强。

### 事务隔离性的实现—常见的并发控制技术

https://www.cnblogs.com/takumicx/p/9998844.html#1-%E8%AE%A4%E8%AF%86%E4%BA%8B%E5%8A%A1